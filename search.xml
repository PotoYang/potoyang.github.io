<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第八章-第五节-总结]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-5-Summary%2F</url>
    <content type="text"><![CDATA[总结在本章中，我们了解了您的服务可能会对入侵者造成的一些攻击。我们希望能够介绍加密的工作原理，以及我们如何利用 Go 的标准软件包来实现加密，以确保我们的服务安全。几乎没有什么可以完全保护自己免受坚定的攻击者的攻击；但是，使用本章中描述的简单技术应该构成您的标准工作实践。实施许多这些技术不会在很大程度上减缓您的开发周期；但是，它会给你一个保证你系统安全的优势。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第五节-总结]]></title>
    <url>%2FTest%2FTest%2F</url>
    <content type="text"><![CDATA[Test]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test001</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第四节-维护]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-4-Maintenance%2F</url>
    <content type="text"><![CDATA[维护保持系统安全的一个重要因素是，确保使用所有最新的安全补丁使其保持最新。这种方法需要应用于您的应用程序代码、服务器的操作系统和应用程序，如果您使用的是 Docker，还需要确保容器是最新的，以确保您没有漏洞。 为容器打补丁保持容器安全的最简单方法之一是确保定期构建和部署容器。通常情况下，如果服务没有处于活跃开发阶段，那么它可能不会在几个月内部署到生产中。由于此问题，您可能正在修补主机级应用程序库（如 OpenSSL），但由于容器提供的应用程序隔离，您可能在容器级别拥有易受攻击的二进制文件。保持最新状态的最简单方法是运行常规构建和部署，即使应用程序代码没有更改。您还需要确保如果在 Dockerfile 中使用基本容器，也会构建和更新它。 Docker hub，quay.io 和其他几个软件作为服务注册表，能够在链接容器更改时自动重建容器。如果要构建基于 golang：latest 的映像，则可以在将上游映像推送到注册表时自动触发构建。您还可以运行自动安全扫描，该扫描会检查映像中的图层并扫描任何 CVE 漏洞。它会让你知道漏洞存在于哪一层，你经常会发现这是在基础层，如 Ubuntu 或 Debian。 软件更新在主机和 Docker 映像中修补软件，可以帮助您远离 Openble 中的 Heartbleed 等漏洞。修补软件更新相对简单。您可以将主机配置为自动更新；我更喜欢的另一个选择是确保您的基础架构自动化，以便您可以将其清除并重建。 修补应用程序代码与主机上的软件需要更新的方式相同，您还必须更新应用程序代码以确保始终拥有最新的更新。通常，遵循将应用程序依赖关系锁定到版本的方法，并使用 Go 1.5 中引入的 vendoring 支持，此过程在社区中不断增长。这个问题的一个问题是，在 1.5 之前的版本中没有出现 vendoring 的主要原因之一是，鼓励您针对最新的软件包构建应用程序代码，并尽快修复因 API 更改而发生的任何问题。如果您确实使用了 vendoring，我肯定不会建议您不使用它，那么您应该每晚运行项目构建，将所有库更新到最新版本。您不一定要将其部署到生产中；但是，如果测试通过那么为什么不呢？即使它是一个没有正在开发的服务，如果测试失败，那么这也应该是你进行维护的理由。 日志记录如果我们保护了密码并实现了良好的安全性，我们仍然需要知道我们会何时受到威胁。在上一章中，我们介绍了日志记录，日志记录可以作为安全策略的一部分。考虑有人试图强行申请登录；当您需要对此威胁做出反应时，跟踪高级别的身份验证错误以及源 IP 可能非常有用。防火墙可以阻止攻击者的 IP 地址。 日志文件的内容需要考虑以下属性： 谁做出的这个行为 什么失败了或是成功了 行为什么时候出现的 为什么这个行为失败或是成功 你如何处理这个问题 以下示例包含的信息远远不够有用，事实上，除了让您知道可能存在故障之外，您甚至可能不会消耗此类日志所占用的空间： Aug 18 11:00:57 [AuthController] Authentication failed 以下示例要好得多；它以更深入的方式显示问题，并详细描述了用户访问系统所采取的事件。现代日志评估工具（如 Kibana）允许过滤和分组此类日志文件，从而可以构建仪表盘或事件列表： Aug 18 11:00:57 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - user unknown - /user/login /user/myaccount Aug 18 11:01:18 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - invalid password - /user/login?err=1 /user/login Aug 18 11:02:01 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - incorrect 2FA code /user/login?err=2 /user/login 例如，您可以创建一个仪表盘，该仪表盘查看来自单个 IP 地址超过特定阈值的失败尝试次数，这可能表示恶意尝试强制访问系统。通常可以对此类事件设置警报，使您可以主动识别威胁并阻止访问。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第二节-外部安全性]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-2-External-Security%2F</url>
    <content type="text"><![CDATA[外部安全性外部安全是保护系统安全的第一道防线，通常包括第 2 层或第 3 层防火墙、DDoS 防护、web 应用防火墙以及其他软件和硬件层面的保护。在攻击者能够危及您的应用程序之前，他们必须首先通过这些硬件和软件层，这些层不是您的应用程序代码的一部分，而是应用程序中许多组件可能共享的共享基础架构层。在本节中，我们将介绍一些外部安全性以及可能对您使用的一些攻击。保护服务的边界通常是由操作完成的任务，但是作为开发人员，我们需要了解流程和风险，因为它极大地增强了我们加固应用程序代码的能力。在本节中，我们将介绍外部安全性的通用方法以及黑客可以利用您的系统的一些方法。 第 2 或第 3 层防火墙第 2 层更常用于路由，因为它只处理 MAC 地址而不处理 IP 地址，而第 3 层可识别 IP 地址。根据传统，第 2 层是唯一真正的不会增加延迟的方法，因为它的执行速度与网线速度大致相同。随着处理能力和内存的增加，第 3 层现在也以网线速度运行，一般来说，当我们查看边缘防火墙时（通常是系统的第一个入口点），它们现在将会是第 3 层。那么这给了我们什么提示呢？首先，它阻止边缘网络不需要的流量：我们限制外部世界可访问的端口，同时一些导向不允许访问内容的流量在防火墙处被拦截，这样就没有机会从源上进行攻击。除此之外，它还允许我们限制对某些端口的访问。例如，如果您正在运行服务器，则很可能需要某种形式的远程访问，例如 SSH。2015 年出现的 Heartbleed 漏洞利用了 OpenSSH 中的漏洞，直接暴露在网络上的 SSH 服务器很容易受到这种攻击。有效地使用防火墙意味着 SSH 等专用端口将被锁定到 IP 地址或 IP 范围，这可能是您的 VPN、办公室 IP 或公共 IP。这大大减少了攻击者利用此功能进行攻击的媒介，因此当您运行易受 Heartbleed 攻击的 OpenSSH 版本时，你需要将这些 SSH 连接置于受保护区域内。 Heartbleed 漏洞利用了执行缓冲区溢出的能力进行攻击，例如，您要求服务器提供 4 个字母的单词，但指定长度为 500；你得到的是 4 个字母的单词，剩下的 496 个字符是跟随初始分配的内存地址的内存块。实际上，这就允许黑客随机访问服务器中的内存块；这些内存块可能包含更改密码请求等项目，这些项目为其提供访问服务器的凭据。如果您正在运行全局可用的 SSH 服务器，那么您可能会发现存在问题： Web 应用程序防火墙Web 应用程序防火墙（WAF）被配置为系统中的第二道或第三道防线。要了解 WAF 是什么，让我们看看 开源 Web 应用程序安全项目（OWASP）中的定义： “Web 应用程序防火墙（WAF）是 HTTP 应用程序的防火墙。它将一组规则应用于 HTTP 会话。这些规则涵盖了常见的攻击，如跨站点脚本（XSS）和 SQL 注入。 当代理技术保护客户端时， WAF 保护着服务器。部署 WAF 以保护特定 web 应用程序或 web 应用程序集。WAF 可以被视为反向代理。 WAF 可能以应用、服务器插件或过滤器的形式出现，并且可以针对应用程序进行定制。执行此自定义的工作量很大，需要在修改应用程序时进行维护。“ OWASP 是一个非常有用的资源，实际上为 ModSecurity 提供了一个核心规则集，可以防止 SQL 注入、XSS、Shellshock 等攻击。设置 WAF（如ModSecurity 和 OWASP CRS）应该是您的最低要求。在 Docker 容器中托管这个应该是相对微不足道的，这可能形成第 2 层防火墙后面的第二道防线。 还有另一种选择：一些像 Cloudflare 这样的 CDN 公司提供托管的 WAF。这是对网络边缘的保护，并且由于Cloudflare 等企业的专业知识，您无需担心配置问题。事实上，Cloudflare 支持 OWASP CRS。 API 网关除了 WAF，API 网关也是一个有用的工具；这可以实现双重目的，即将公共 API 路由到其后端服务以及一些其他功能，例如边缘的令牌验证以及输入验证和转换。当我们谈到困惑的代理人问题时，防火墙后面的攻击者可以执行他们没有权限的命令，我们研究了加密网络令牌的可能性；这个问题是用于解密这些令牌的私钥需要分布在多个后端服务中。这使得管理密钥比其应有的难度更具挑战性。API 网关可以通过成为唯一可以解密消息的层来简化这种情况。其他服务使用公钥来验证签名。API 网关通常实现许多其他第一线功能，例如但不限于以下内容： 请求验证 授权 速度限制 日志记录 缓存 请求和响应传递 WAF 和 API 网关之间存在交叉元素；但是，这两个应该被视为基础设施的两个截然不同的部分。关于 API 网关的提供者，这似乎是一个发展中的领域；AWS 具有高级 API 网关，如果您已购买 AWS PaS环境，则可以使用该网关。 对于独立部署，Kong，Tyk，Apigee，Mashery 和 Mulesoft 的 Anypoint Platform 都是该领域的领导者。当然，可以使用 Nginx 或 HAProxy 构建自己的 API 网关；但是，在开始构建自己的平台之前，我建议首先要看一看以上特定平台中的一个。 DDoS 防护2016 年 10 月 21 日，攻击者使用 Mirai 僵尸网络攻击 DYN 的 DNS 服务器造成了一次大规模的网络瘫痪。Mirai 漏洞利用了中国的雄迈信息技术有限公司制造的 IP 摄像机和 DVR 的漏洞攻击者不是攻击目标，而是决定取消互联网基础设施的主要部分，淘汰美国东海岸和西海岸的大部分地区。Mirai 漏洞只利用 60 个用户名和密码来尝试更新易受攻击设备的固件。一旦安装了恶意软件，该设备就可以被僵尸网络控制。剩下要做的就是告诉机器人开始针对 DYN 域名服务器进行 DNS 攻击。 Mirai 的代码已经发布在网上；你可以使用谷歌轻易地找到它。你会为这个代码的简单程度感到惊讶。现在，我不想从设计这种攻击的复杂性中得到任何东西；我只谈谈实现。该漏洞的相当大一部分代码是用 Go 编写的，因此非常易读。channel（通道）有一些很好的用途。如果您查看代码，请尝试甄别可以使用信号量改进的代码段。 Akamai 发布的一份报告指出，今年所有攻击中有 98.34％ 是面向基础设施的，只有 1.66％ 的目标是应用层。在 98.34％ 中，只要保持网络环境干净，许多是可以避免的。让我们看看顶级威胁及其运作方式。 DDoS 攻击类型以下是 DDoS 攻击的类型“ UDP 碎片 DNS NTP Chargen UDP SYN SSDP ACK UDP 碎片攻击UDP 碎片攻击是攻击者利用数据报碎片在网络上工作的方式。每个网络都有一个称为最大传输单元（MTU）的限制。如果发送到网络的数据报大于 MTU，则其会被分割成碎片进行传输。 UDP 碎片攻击的工作原理是创建包含假包的数据报；当服务器试图重新组装这些包时，它无法完成，资源很快就会被消耗殆尽。 UDP 泛洪攻击UDP 泛洪攻击的工作原理是将大量带有欺骗源地址的 UDP 数据包发送到 IP 地址。服务器将响应这些请求，向欺骗的地址发送回复。由于大量的攻击，路由器将超过其每秒 UDP 数据报的限制，并在一段时间内对同一安全区域中的所有地址停止发送消息。 这通常也使用称为反射攻击的技术。当源地址 IP 被欺骗时，返回数据包不会被发送回真实源，而是发到被欺骗的 IP 地址。使用此技术的原因是它允许发送方通过仅消耗出站数据包上的资源来放大攻击。 DNSDNS 攻击利用 UDP 泛洪攻击来获取 DNS 服务器；许多请求被用于查询 DNS 服务器。这些请求旨在从一个微小的请求返回一个非常庞大的回复，以最大限度地提高攻击效率，因为发送者通常不会收到响应。 我们在早些时候看到的针对 Dyn 的基础设施的攻击，在 2016 年 10 月在美国东海岸和西海岸取出了许多网站，这种攻击就是 DNS 攻击。与大多数 DNS 攻击不同，Miraia 网络不使用反射攻击技术，它允许将响应返回给发送方，这可能是由于大量受损设备造成的。 NTPNTP 是另一种放大攻击，它利用 NTP 服务器内置的功能，返回最后 600 台与之交互的机器。此攻击利用了支持 MONLIST 命令且尚未修补的开放 NTP 服务器。项目 http://openntpproject.org/ 旨在识别未修补的服务器，以鼓励删除此漏洞。不幸的是，NSFOCUS 在 2014 年进行的研究发现，全球有超过 17,000 台服务器容易受到攻击。假设所有这些服务器都可以使用，并且使用 2014 年遭遇 CloudFlare 的 NTP 攻击的有效载荷大小，我们就有了 1.4Tbps 的 DDoS 攻击能力。这种流量将是目前已知的最大攻击的两倍。NTP 为最强大的应用程序攻击之一提供了一个平台，并且仅由于服务器修补不良而存在。 CHARGENCHARGEN（字符生成协议）攻击是另一种反射放大攻击。攻击利用开放的 CHARGEN 服务器，每次从连接的主机接收数据报时，在端口 19 上运行的服务器将返回 0 到 512 之间的随机字符长度。CHARGEN 旨在作为一种字节流的源来调试 TCP 网络代码和带宽测量。CHARGEN 攻击通过滥用已在网络连接的打印机上启用的 CHARGEN 服务器来工作。 SSDP简单服务发现协议（SSDP），通常用于发现 即插即用（UPnP）设备。这正是您的家用路由器实现的协议，所以下次当您抱怨您最喜欢的游戏网络离线时，为什么不先检查您是否无意中将 SSDP 暴露在互联网上？ ACKACK 泛洪利用客户端连接到服务器时存在的三次握手。第一步是客户端发送一个 SYN 数据包，从服务器回复 SYN-ACK 数据包。然后客户端最后回复一个 ACK 数据包，然后为数据开放连接。ACK 泛洪采用以下两种形式之一： 攻击者向服务器发送一个欺骗性的 SYN 数据包，然后使用一个伪造的 SYN-ACK 数据包。服务器打开并保持开放的连接。如果打开了足够多的连接，则服务器最终将耗尽资源。 第二种方法是仅发送 ACK 包。由于服务器没有开放连接，因此该数据包将被丢弃；但是，它仍然消耗必须处理这些数据包的资源。 攻击类似于 SYN 攻击；但是，由于它欺骗 DDoS 过滤器将数据包传递到服务器的方式，它可以更有效。 避免这些攻击并非如此简单：您需要在网络边缘检测并过滤此活动。您还需要大量带宽来吸收系统入站的流量，在我看来，这不是内部解决方案可以或应该解决的问题。 避免 DDoS 攻击的第一道防线是确保您没有启用它们。配置防火墙以确保您不暴露易受攻击的服务，并修补您的服务意味着攻击者无法使用您的网络基础架构来攻击其他人。第二条是利用 Cloudflare，Akamai，Imperva 或其他拥有基础架构和网络过滤器的专家的力量，来确保流量永远不会到达您的服务器。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第一节-加密与签名]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-1-Encryption-and-Signing%2F</url>
    <content type="text"><![CDATA[加密和签名当我们研究保护数据的方式时，无论是静态还是动态，我们讨论的许多方法都将以加密方式保护数据。 ”密码学是使用数学来加密和解密数据的科学。密码学使你能够存储敏感信息或通过不安全的网络（像互联网这样的线路）传输它，这样除了预期的接收者之外，任何人都无法读取它。“ – 密码学概论，Network Associates 公司 作为我们将在本章讨论的事情的基础，我们必须首先了解密码学如何工作的，不是需要我们有数学学位，而是只到涉及所涉及的部分的程度。密码学与所涉及的密钥的安全性差不多，我们需要知道哪些密钥可以自由分发，哪些密钥需要用我们的生命去保护。 对称密钥加密对称密钥加密也称为秘密密钥或传统密码术：一个密钥用于数据的加密和解密。要使远端能够解密此信息，它必须首先拥有密钥，并且必须安全地保存此密钥，因为一个服务器的单一泄密将危害共享此密钥的所有服务器。它还会使密钥管理变得更加复杂，因为当你需要更改密钥时，你应该经常更改它，你需要在整个磁盘中推出此更改。 公钥加密公钥加密由 Whitfield Diffie 和 Martin Hellman 于 1975 年引入，以满足双方需要了解秘密的需要。事实上，他们并不是第一个发明这一点的人；它是几年前英国特勤局开发的，但却保留了军事秘密。 公钥加密使用一对密钥进行加密；你也会听到称它为非对称加密。公钥用于加密信息，而私钥只能用于解密。由于无法从公钥中确定私钥，因此公钥通常会发布到全世界。 数字签名公钥加密还使我们能够使用数字签名。数字签名工作方式是，通过使用私钥加密消息然后传输签名消息。如果可以使用公钥解密消息，则消息必须源自私钥的持有者。由于加密消息的计算时间和有效载荷大小的增加，标准方法是创建消息的单向哈希，然后使用私钥对其进行加密。接收方将使用公钥解密哈希，并从消息中生成相同的哈希；那么，该消息可以被认为来自可信赖的来源。 X.509 数字证书公钥的一个问题是你必须确保你认为属于收件人的密钥确实由收件人拥有。如果密钥通过公共网络传输，则始终存在中间人攻击的可能性。攻击者可能会伪造一个虚假的公钥，因为你认为它是你信任的收件人；但是，他们可以用他们的密钥替换。这意味着你认为安全传输的消息实际上可能被恶意第三方解密和读取。 为了避免这些问题，数字证书出现了，它简化了确定公钥是否属于报告所有者的任务。 数字证书包含三件事： 一个公钥 证书信息，例如所有者的姓名或 ID 一个或多个数字签名 使证书值得信赖的是数字签名。证书由受信任的第三方或证书颁发机构（CA）签名，该机构担保你的身份和你的公钥是属于你的。任何人都可以创建 CA 根证书并签署他们的证书，对于诸如微服务间通信等系统的非公共访问，这是一种常见的做法。但是，对于公共证书，你需要向 CA 支付签署证书的费用。定价的目的是 CA 将会确保你确实是你所说的人；目前，最受欢迎的 CA 是 Comodo、 Symantec （前身为 Verisign）和GoDaddy。你在浏览器中看到挂锁的原因不仅仅是因为你使用的是安全通信，而且您的浏览器已经验证了证书的签名是否与 100 个左右的可信第三方之一捆绑在一起。 TSL/SSLSSL 是两个系统之间安全传输数据的常用术语，它是对 Mozilla 于 1995 年首次开发的弃用标准的引用。它已被 2008 年 8 月发布的 TLS 1.2 取代；虽然 SSL 3.0 在技术上仍然有效，但在针对 POODLE（Paddling Oracle On Downgraded Legacy Encryption）攻击的漏洞后，它在 2015 年 6 月被弃用。2014 年，Google 安全研究团队发现的 POODLE 攻击工作原理是攻击者向服务器发出多个请求，然后分析和使用这些数据，这些数据使他们能够解密传输中的数据。平均而言，只需要进行 256 次 SSL 3.0 调用即可解密 1 字节的信息。 这意味着该漏洞在公开披露之前已存在 18 年；你可能会问为什么人们在强大的 TLS 1.0 发布 15 年后仍在使用 SSL 3.0？这是由于某些浏览器和服务器不支持 TLS 1.0 的问题，因此存在一个回退到较低级别加密的回退。尽管在发现时，几乎没有人仍在使用 SSL 3.0，但回退仍然在协议中，因此可被黑客利用。解决方案非常简单：在服务器配置中禁用低于 TLS 1.0 的任何内容。我们了解了一些 TLS 和 SSL 的历史，但它如何保证您的数据安全？ TLS 使用对称加密，其中客户端和服务器都有一个用于加密和解密的密钥。如果你还记得上一节，我们介绍了对称加密和分发密钥的问题。TLS 通过在握手的第一部分使用非对称加密来解决这个问题。客户端从服务器检索包含公钥的证书并生成随机数；它使用公钥加密此随机数并将其发送回服务器。现在双方都有随机数，他们使用它来生成对称密钥，用于传输过程中对数据加密和解密。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-安全性]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-0-Security%2F</url>
    <content type="text"><![CDATA[安全性微服务中的安全性可能就像一个雷区，在某种程度上确实是这样。本章主要介绍一些可以提高 Go 代码安全性的方法；但是，我觉得讨论一些更为广泛的问题也很重要。对防火墙配置等话题的深入讨论最好留给专业的书籍；但是，我们将介绍一些概念和所面临的问题，以便您可以为进一步阅读做好最充分的准备。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
