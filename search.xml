<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[InterviewBit-Day9]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day10%2F</url>
    <content type="text"><![CDATA[PracticeLength of Last WordGiven a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Given s = &quot;Hello World&quot;, return 5 as length(&quot;World&quot;) = 5. Please make sure you try to solve this problem without using library functions. Make sure you only traverse the string once. 1234567891011121314151617181920212223public class Solution &#123; // DO NOT MODIFY THE LIST. IT IS READ ONLY public int lengthOfLastWord(final String A) &#123; int len = A.length(); if (len == 0) &#123; return 0; &#125; int count = 0; int i = len - 1; int end = len - 1; while (i &gt;= 0 &amp;&amp; A.charAt(i) == ' ') &#123; i--; &#125; while (i &gt;= 0 &amp;&amp; A.charAt(i) != ' ') &#123; i--; count++; &#125; return count; &#125;&#125; Roman To IntegerGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Read more details about roman numerals at Roman Numeric System Example : 12Input : &quot;XIV&quot;Return : 14 12Input : &quot;XX&quot;Output : 20 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int romanToInt(String A) &#123; int l = A.length(); if(l==0) return 0; int sum = 0; for(int i=0;i&lt;l-1;i++) &#123; char c = A.charAt(i); char cn = A.charAt(i+1); int valc = value(c); int valcn = value(cn); if(valc == 0) continue; else if(valcn == 0 || valc&gt;=valcn) sum += valc; else sum -= valc; &#125; sum += value(A.charAt(l-1)); return sum; &#125; static int value(char c) &#123; if(c == 'I') return 1; else if(c == 'V') return 5; else if(c == 'X') return 10; else if(c == 'L') return 50; else if(c == 'C') return 100; else if(c == 'D') return 500; else if(c == 'M') return 1000; return 0; &#125;&#125; Justified TextGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.Extra spaces between words should be distributed as evenly as possible.If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.For the last line of text, it should be left justified and no extra space is inserted between words. Your program should return a list of strings, where each string represents a single line. Example: words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;] L: 16. Return the formatted lines as: 12345[ "This is an", "example of text", "justification. "] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ArrayList&lt;String&gt; fullJustify(ArrayList&lt;String&gt; A, int B) &#123; ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;(); int i = 0, j = 0; while (i &lt; A.size()) &#123; int len = 0; StringBuilder sb = new StringBuilder(); while (i &lt; A.size() &amp;&amp; len &lt;= B) &#123; len += A.get(i++).length() + 1; &#125; len--; if (len &gt; B) &#123; len -= A.get(--i).length() + 1; int space = 0, w = 0; if(i!=j+1) &#123; space = (B - len)/(i - j-1); w = (B - len)%(i - j-1); &#125; for (int k = j; k &lt; i; k++) &#123; sb.append(A.get(k)); if(k == i-1) break; for(int a = 0; a &lt; space; a++) sb.append(" "); if(w &gt; 0) &#123; w--; sb.append(" "); &#125; sb.append(" "); &#125; j = i; &#125; else &#123; for (int k = j; k &lt; i; k++) &#123; sb.append(A.get(k)).append(" "); &#125; if (sb.length() &gt; B) sb.deleteCharAt(sb.length()-1); j = i; &#125; while (sb.length() &lt; B) &#123; sb.append(" "); &#125; ans.add(sb.toString()); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day9]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day9%2F</url>
    <content type="text"><![CDATA[PracticePalindrome StringGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example: &quot;A man, a plan, a canal: Panama&quot; is a palindrome. &quot;race a car&quot; is not a palindrome. Return 0 / 1 ( 0 for false, 1 for true ) for this problem 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int isPalindrome(String A) &#123; String start, end; for (int i = 0, j = A.length() - 1; i &lt; j; ) &#123; if ((A.charAt(i) &gt;= 'a' &amp;&amp; A.charAt(i) &lt;= 'z') || (A.charAt(i) &gt;= 'A' &amp;&amp; A.charAt(i) &lt;= 'Z') || (A.charAt(i) &gt;= '0' &amp;&amp; A.charAt(i) &lt;= '9')) &#123; start = String.valueOf(A.charAt(i)); i++; &#125; else &#123; i++; continue; &#125; if ((A.charAt(j) &gt;= 'a' &amp;&amp; A.charAt(j) &lt;= 'z') || (A.charAt(j) &gt;= 'A' &amp;&amp; A.charAt(j) &lt;= 'Z') || (A.charAt(j) &gt;= '0' &amp;&amp; A.charAt(j) &lt;= '9')) &#123; end = String.valueOf(A.charAt(j)); j--; &#125; else &#123; j--; i--; continue; &#125; if (start.length() != 0 &amp;&amp; end.length() != 0) &#123; if (!start.equalsIgnoreCase(end)) &#123; return 0; &#125; &#125; &#125; return 1; &#125;&#125; Amazing SubarraysYou are given a string S, and you have to find all the amazing substrings of S. Amazing Substring is one that starts with a vowel (a, e, i, o, u, A, E, I, O, U). Input 1Only argument given is string S. Output 1Return a single integer X mod 10003, here X is number of Amazing Substrings in given string. Constraints 121 &lt;= length(S) &lt;= 1e6S can have special characters Example 123456789101112131415Input ABECOutput 6Explanation Amazing substrings of given string are : 1. A 2. AB 3. ABE 4. ABEC 5. E 6. EC here number of substrings are 6 and 6 % 10003 = 6. 123456789101112131415161718192021public class Solution &#123; public int solve(String A) &#123; int len = A.length(); if (len == 0) &#123; return 0; &#125; int count = 0; for (int i = 0; i &lt; len; i++) &#123; if (A.charAt(i) == 'a' || A.charAt(i) == 'e' || A.charAt(i) == 'i' || A.charAt(i) == 'o' || A.charAt(i) == 'u' || A.charAt(i) == 'A' || A.charAt(i) == 'E' || A.charAt(i) == 'I' || A.charAt(i) == 'O' || A.charAt(i) == 'U') &#123; count = count + len - i; &#125; count = count % 10003; &#125; return count; &#125;&#125; Minimum Characters required to make a String PalindromicYou are given a string. The only operation allowed is to insert characters in the beginning of the string. How many minimum characters are needed to be inserted to make the string a palindrome string Example:Input: ABCOutput: 2Input: AACECAAAAOutput: 2 1234567891011121314151617public class Solution &#123; public int solve(String A) &#123; String B = new StringBuilder(A).reverse().toString(); int count = 0; for (int i = 0, j = 0; i &lt; A.length() &amp;&amp; j &lt; B.length();) &#123; if (B.charAt(j) == A.charAt(i)) &#123; i++; j++; &#125; else &#123; count++; i = 0; j = count; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试-翼果科技]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95-%E7%BF%BC%E6%9E%9C%E7%A7%91%E6%8A%80%2F</url>
    <content type="text"><![CDATA[翼果（深圳）科技有限公司介绍翼果（深圳）科技有限公司成立于2015年，公司核心成员来自华为等知名企业，主要合伙人具有500强企业10年以上工作经验和海外工作经历，团队技术实力强，具备国际化视野。 公司研发由多名顶级技术专家领衔，产品和技术氛围浓郁，作风务实，注重研发基础能力建设和技术积累，员工技能培训完善，技术能力成长快。公司已与众多企业客户建立业务合作关系，并获得知名机构投资，业务和团队处于蓬勃发展期，员工职业晋升快，发展空间大。 公司人际关系简单，倡导多劳多得和责任结果导向，实行骨干员工全员持股，提供具备行业竞争力的综合福利待遇。 如果您有梦想、有意愿、有能力，希望通过自己的拼搏获得快速的成长和丰厚的回报，我们热切欢迎您加入我们的队伍，共同奋斗成长！ 所在行业TouchData是一家专注于出海电商行业的营销数据服务商，公司拥有多款行业领先的大数据分析和精准营销产品，是中国出海电商领域用户数据分析和精准营销应用的市场领导者。 公司产品及服务覆盖数据采集、清洗、分析、用户管理、智能营销推广等多个领域，数据分析和应用能力行业领先，产品差异化优势明显，已为出海电商行业数千家中小企业和众多数十亿级别的电商巨头提供成功的数据和营销解决方案服务。 面试流程笔试、一面技术面、二面逻辑题、三面老总面谈 笔试一共三道大题 Java 基础题两个类，B 类继承于 A 类。A 类内部有一个字段，已经被初始化，同时有对字段的 get()、set() 方法。B 类继承于 A 类，重写 A 类的 set() 方法。在 main() 方法中，对对应的 A、B 类多态行为进行考察。 主要考察对 Java 基础知识多态的掌握，在实际类中的运用情况。 SQL 语句编写1、对 limit 的运用 2、对时间函数的运用 3、对 group by 的运用 4、对 order by 的运用 编程题统计 words.txt 中单词出现的次数 一面技术面试，涵盖基础知识点 HashMap 和 List 的内部实现 Spring IOC 原理及为什么要用 IOC Spring AOP 原理 Spring 事务处理 MyBatis 如何解析生成 SQL 语句 项目中你用了什么，对项目有什么样的改进 SQL 语句调优（不定期出现 SQL 语句查询变慢） JVM 分区 二面逻辑面试 3L、5L 杯子量出 4L 水 三个女儿年龄问题 大学学习的软件方面科目 学习科目中哪个科目最好 三面为什么要离开上一家 有什么想了解的 为什么选择来深圳 学习东西依靠被人带还是自己能行 为什么要来我们公司 有什么问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day8]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day8%2F</url>
    <content type="text"><![CDATA[PracticeGreatest Common DivisorGiven 2 non negative integers m and n, find gcd(m, n) GCD of 2 integers m and n is defined as the greatest integer g such that g is a divisor of both m and n.Both m and n fit in a 32 bit signed integer. Example 1234m : 6n : 9GCD(m, n) : 3 NOTE : DO NOT USE LIBRARY FUNCTIONS 123456789101112131415161718192021222324252627282930public class Solution &#123; public int gcd(int A, int B) &#123; if (A == B) &#123; return A; &#125; if (B == 0 || A == 0) &#123; return 1; &#125; if (A &gt; B) &#123; int temp = A; A = B; B = temp; &#125; ArrayList&lt;Integer&gt; AFactories = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= A; i++) &#123; if (A%i == 0) &#123; AFactories.add(i); &#125; &#125; for (int i = AFactories.size() - 1; i &gt;= 0; i--) &#123; if (B%AFactories.get(i) == 0) &#123; return AFactories.get(i); &#125; &#125; return 1; &#125;&#125; Rearrange ArrayRearrange a given array so that Arr[i] becomes Arr[Arr[i]] with O(1) extra space. Example: 12Input : [1, 0]Return : [0, 1] Lets say N = size of the array. Then, following holds true : All elements in the array are in the range [0, N-1] N * N does not overflow for a signed integer 123456789101112131415public class Solution &#123; public void arrange(ArrayList&lt;Integer&gt; a) &#123; int n = a.size(); for (int i = 0; i &lt; n; i++) &#123; int v = a.get(i); int w = a.get(v) % n; int x = v + w * n; a.set(i, x); &#125; for (int i = 0; i &lt; n; i++) &#123; int v = a.get(i); a.set(i, v/n); &#125; &#125;&#125; Palindrome IntegerDetermine whether an integer is a palindrome. Do this without extra space. A palindrome integer is an integer x for which reverse(x) = x where reverse(x) is x with its digit reversed.Negative numbers are not palindromic. Example : 12345Input : 12121Output : TrueInput : 123Output : False 1234567891011121314151617public class Solution &#123; public boolean isPalindrome(int a) &#123; if(a == check(a)) return true; else return false; &#125; public int check(int num)&#123; int reverted = 0; while (num &gt; 0) &#123; reverted = reverted*10 + num%10; num /= 10; &#125; return reverted; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oauth2 初步]]></title>
    <url>%2FOauth2%2FOauth2-%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[搭建一个最简单的 Oauth2 认证服务基于 Springboot2，在 pom.xml 中引入 Oauth2： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 完成认证服务器的自动配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 xxxApplication 上添加 @EnableAuthorizationServer 注解： 123456789@EnableAuthorizationServer@SpringBootApplicationpublic class SecurityOauth2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityOauth2Application.class, args); &#125;&#125; 启动项目，会在控制台打印： 12security.oauth2.client.client-id = 3c7748b1-ff89-4643-8e16-56fc2ae77a3csecurity.oauth2.client.client-secret = 08ed0119-8e8e-4a24-83c7-ac249f8ba1a3 先使用 Git Bash 进行 token 获取测试： 1$ curl 3c7748b1-ff89-4643-8e16-56fc2ae77a3c:08ed0119-8e8e-4a24-83c7-ac249f8ba1a3@localhost:8888/oauth/token -dgrant_type=client_credentials -dscope=any 然后使用 postman 进行 token 获取： 这里 Username 相当于 client_id，Password 相当于 client_secret 爬坑：对于 postman 进行测试，困扰了半天，之前都是把 client_id、client_secret、grant_type、scope 字段全部填到 Params 中，然后进行请求返回的数据全部都是： 12345678&gt;&#123;&gt; "timestamp": "2019-06-18T06:44:16.443+0000",&gt; "status": 401,&gt; "error": "Unauthorized",&gt; "message": "Unauthorized",&gt; "path": "/oauth/token"&gt;&#125;&gt; 经过不断尝试，找到需要将 client_id 和 client_secret 整合在一起，然后通过 Base64 加密后连接到 Authorization 后放到 Header 里面进行传输，对应到 postman 中就是在 Authorization 中选择 Basic Auth，填写 Username 和 Password。但是在 Git Bash 中使用 curl 就能够直接进行请求连接，目前还不清楚 curl 请求的时候是如何处理的。 参数设置完成后，发起请求： 根据 Git Bash 和 postman 的请求结果可以看出两次使用相同client_id 和 client_secret 在不同时间发起请求，得到的 access_token 值是一样的，而 expires_in 过期时间的值在对应减小。 上面使用的是 Oauth2 自动生成的 client_id 与 client_secret，这里我们可以自己定义 client_id 与 client_secret，直接在 application.yml 中添加如下配置： 12345security: oauth2: client: client-id: test client-secret: test 启动项目，控制台中打印： 12security.oauth2.client.client-id = testsecurity.oauth2.client.client-secret = **** 使用 postman 做测试，修改其中 Username 和 Password 为 test，发起请求，得到结果： 123456&#123; "access_token": "10093ccd-80ec-44c7-84fa-cd75c96a5309", "token_type": "bearer", "expires_in": 43199, "scope": "any"&#125; 到这里就完成了最基本的 Oauth2 授权获取 token，使用的都是 Oauth2 的客户端模式。 后记： 在项目启动的时候总是会出现： 123456789101112131415&gt; 2019-06-18 19:08:46.530 INFO 12208 --- [nio-8888-exec-1] o.apache.coyote.http11.Http11Processor : Error parsing HTTP request header&gt; Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.&gt; &gt; java.lang.IllegalArgumentException: Invalid character found in method name. HTTP method names must be tokens&gt; at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:414) ~[tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:294) ~[tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_161]&gt; at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_161]&gt; at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]&gt; at java.lang.Thread.run(Thread.java:748) [na:1.8.0_161]&gt; 这个异常，对于项目的运行目前没有看出有什么影响。 找了很久都未能找到解决方案，后面再继续看看吧。]]></content>
      <categories>
        <category>Oauth2</category>
      </categories>
      <tags>
        <tag>Oauth2 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue前端开发流程总结]]></title>
    <url>%2FVue%E6%95%99%E7%A8%8B%2FVue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Vue 开发流程总结由于主要做后端开发，对于前端开发不怎么熟悉，在最近学习 vue 后，下载了一个 vue-admin 快速开发框架，框架中把基本需要的组件都集成好了，在实现功能的时候，对相关的页面进行一定的修改就能达到目的。 由此，各个不同业务对应的修改流程是差不多的，这里做一个小的总结。 基本页面确定业务需要什么页面就对其进行复制，然后在复制后的页面上进行修改。 前后端交互 页面引用 api 目录下对应的文件，其中定义了前后端交互接口及方式 api 中引用了 request.js 其中定义了前后端交互的服务器地址 前端对返回的数据进行相应解析 前端效果控制在页面获取相应的数据后，需要进行数据加载，然后页面呈现出相应的效果，同时根据业务的需要进行页面元素修改。]]></content>
      <categories>
        <category>Vue教程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day7]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day7%2F</url>
    <content type="text"><![CDATA[PracticeMAXSPPRODYou are given an array A containing N integers. The special product of each i^th^ integer in this array is defined as the product of the following: LeftSpecialValue: For an index i, it is defined as the index j such that A[j]&gt;A[i] (i&gt;j). If multiple A[j]’s are present in multiple positions, the LeftSpecialValue is the maximum value of j. RightSpecialValue: For an index i, it is defined as the index j such that A[j]&gt;A[i] (j&gt;i). If multiple A[j]s are present in multiple positions, the RightSpecialValue is the minimum value of j. Write a program to find the maximum special product of any integer in the array. Input: You will receive array of integers as argument to function. Return: Maximum special product of any integer in the array modulo 1000000007. Note: If j does not exist, the LeftSpecialValue and RightSpecialValue are considered to be 0. Constraints 1 &lt;= N &lt;= 10^5^ 1 &lt;= A[i] &lt;= 10^9^ 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int maxSpecialProduct(ArrayList&lt;Integer&gt; A) &#123; int n = A.size(); int[] left = new int[n]; int[] right = new int[n]; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); q.addLast(0); for(int i = 1; i &lt; n; i++)&#123; while(!q.isEmpty())&#123; if(A.get(q.getLast()) &gt; A.get(i)) break; q.removeLast(); &#125; left[i] = (q.isEmpty()) ? 0 : q.getLast(); q.addLast(i); &#125; q = new ArrayDeque&lt;&gt;(); q.addLast(n - 1); for(int i = n - 2; i &gt;= 0; i--)&#123; while(!q.isEmpty())&#123; if(A.get(q.getLast()) &gt; A.get(i)) break; q.removeLast(); &#125; right[i] = (q.isEmpty()) ? 0 : q.getLast(); q.addLast(i); &#125; long mx = -1; for(int i = 0; i &lt; n; i++)&#123; mx = Long.max(mx, 1L * left[i] * right[i]); &#125; return (int)(mx % 1000000007); &#125;&#125; Prime SumGiven an even number ( greater than 2 ), return two prime numbers whose sum will be equal to given number. NOTE A solution will always exist. read Goldbach’s conjecture Example: 12Input : 4Output: 2 + 2 = 4 If there are more than one solutions possible, return the lexicographically smaller solution. 123456If [a, b] is one solution with a &lt;= b,and [c,d] is another solution with c &lt;= d, then[a, b] &lt; [c, d] If a &lt; c OR a==c AND b &lt; d. 123456789101112131415161718192021222324public class Solution &#123; public ArrayList&lt;Integer&gt; primesum(int A) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; A; i++) &#123; if (isPrime(i) &amp;&amp; isPrime(A - i)) &#123; ret.add(i); ret.add(A - i); return ret; &#125; &#125; return ret; &#125; private boolean isPrime(int num) &#123; int s = (int) Math.sqrt(num); for (int i = 2; i &lt;= s; i++) &#123; if (num%i == 0) &#123; return false; &#125; &#125; return true; &#125;&#125; Excel Column NumberGiven a column title as appears in an Excel sheet, return its corresponding column number. Example: 12345678910111213A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 123456789101112public class Solution &#123; public int titleToNumber(String A) &#123; int len = A.length(), t = 0, ret = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; char temp = A.charAt(i); ret += (temp - 'A' + a) * (int)Math.pow(26, t); t++; &#125; return ret; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day6]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day6%2F</url>
    <content type="text"><![CDATA[PracticeSet Matrix ZerosGiven an m x n matrix of 0s and 1s, if an element is 0, set its entire row and column to 0. Do it in place. Example Given array A as 1231 0 11 1 1 1 1 1 On returning, the array A should be : 1230 0 01 0 11 0 1 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public void setZeroes(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; a) &#123; ArrayList&lt;Integer&gt; cols = new ArrayList&lt;&gt;(); boolean flag = false; for (int i = 0; i &lt; a.size(); i++) &#123; ArrayList&lt;Integer&gt; b = a.get(i); for (int j = 0; j &lt; b.size(); ) &#123; if (flag) &#123; if (a.get(i).get(j) == 0) &#123; cols.add(j); &#125; a.get(i).set(j, 0); j++; &#125; else &#123; if (b.get(j) == 0) &#123; flag = true; j = 0; &#125; else &#123; j++; &#125; &#125; &#125; flag = false; &#125; for (int i = 0; i &lt; a.size(); i++) &#123; ArrayList&lt;Integer&gt; b = a.get(i); for (int j = 0; j &lt; b.size(); j++) &#123; if (cols.contains(j)) &#123; a.get(i).set(j, 0); &#125; &#125; &#125; &#125;&#125; First Missing IntegerGiven an unsorted integer array, find the first missing positive integer. Example: Given [1,2,0] return 3, [3,4,-1,1] return 2, [-8, -7, -6] returns 1 Your algorithm should run in O(n) time and use constant space. 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public int firstMissingPositive(ArrayList&lt;Integer&gt; A) &#123; Collections.sort(A); if (A.size() == 1) &#123; if (A.get(0) &lt;= 0 || A.get(0) != 1) &#123; return 1; &#125; else &#123; return 2; &#125; &#125; boolean flag = false; for (int i = 0; i &lt; A.size() - 1; i++) &#123; if (A.get(i) &lt;= 0) &#123; flag = true; continue; &#125; else &#123; if (i == 0 || flag) &#123; if (A.get(i) != 1) &#123; return 1; &#125; &#125; if ((A.get(i) + 1) != A.get(i + 1)) &#123; return A.get(i) + 1; &#125; flag = false; &#125; &#125; if (flag) &#123; return 1; &#125; return A.get(A.size() - 1) + 1; &#125;&#125; Rotate MatrixYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You need to do this in place. Note that if you end up using an additional array, you will only receive partial score. Example: If the array is 1234[ [1, 2], [3, 4]] Then the rotated array becomes: 1234[ [3, 1], [4, 2]] 1234567891011121314public class Solutoion &#123; public void rotate(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; a) &#123; int n = a.size(); for (int i = 0; i &lt; n / 2; i++) &#123; for (int j = i; j &lt; n - 1 - i; j++) &#123; int temp = a.get(i).get(j); a.get(i).set(j, a.get(n - 1 - j).get(i)); a.get(n - 1 - j).set(i, a.get(n - 1 - i).get(n - 1 - j)); a.get(n - 1 - i).set(n - 1 - j, a.get(j).get(n - 1 - i)); a.get(j).set(n - 1 - i, temp); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day5]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day5%2F</url>
    <content type="text"><![CDATA[PracticeMerge IntervalsGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Given intervals [1,3],[6,9] insert and merge [2,5] would result in [1,5],[6,9]. Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] would result in [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. Make sure the returned intervals are also sorted. 123456789101112131415161718192021222324252627282930/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public ArrayList&lt;Interval&gt; insert(ArrayList&lt;Interval&gt; intervals, Interval newInterval) &#123; ArrayList&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for (Interval interval : intervals) &#123; if (interval.end &lt; newInterval.start) &#123; res.add(interval); &#125; else if (interval.start &gt; newInterval.end) &#123; res.add(newInterval); newInterval = interval; &#125; else if (interval.end &gt;= newInterval.start || interval.start &lt;= newInterval.end) &#123; int newStart = Math.min(interval.start, newInterval.start); int newEnd = Math.max(interval.end, newInterval.end); newInterval = new Interval(newStart, newEnd); &#125; &#125; res.add(newInterval); return res; &#125;&#125; Wave ArrayGiven an array of integers, sort the array into a wave like array and return it,In other words, arrange the elements into a sequence such that a1 &gt;= a2 &lt;= a3 &gt;= a4 &lt;= a5..... Example Given [1, 2, 3, 4] One possible answer : [2, 1, 4, 3]Another possible answer : [4, 1, 3, 2] NOTE : If there are multiple answers possible, return the one thats lexicographically smallest.So, in example case, you will return [2, 1, 4, 3] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public ArrayList&lt;Integer&gt; wave(ArrayList&lt;Integer&gt; A) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp = quickSort(A, 0, A.size() - 1); for (int i = 0, j = 1; i &lt; temp.size() - 1 &amp;&amp; j &lt; temp.size(); i += 2, j += 2) &#123; res.add(temp.get(j)); res.add(temp.get(i)); &#125; if (temp.size() % 2 != 0) &#123; res.add(temp.get(temp.size() - 1)); &#125; // Collections.reverse(res); return res; &#125; private ArrayList&lt;Integer&gt; quickSort(ArrayList&lt;Integer&gt; array, int start, int end) &#123; if (start &lt; end) &#123; int partitionIndex = partition(array, start, end); quickSort(array, start, partitionIndex - 1); quickSort(array, partitionIndex + 1, end); &#125; return array; &#125; private int partition(ArrayList&lt;Integer&gt; array, int start, int end) &#123; int pivot = array.get(end); int partitionIndex = start; for (int i = start; i &lt; end; i++) &#123; if (array.get(i) &lt; pivot) &#123; int temp = array.get(i); array.set(i, array.get(partitionIndex)); array.set(partitionIndex, temp); partitionIndex++; &#125; &#125; int temp = array.get(partitionIndex); array.set(partitionIndex, array.get(end)); array.set(end, temp); return partitionIndex; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day4]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day4%2F</url>
    <content type="text"><![CDATA[SortingQuick Sort1234567891011121314151617181920private static int[] quickSort(int[] A, int start, int end) &#123; if (start &lt; end) &#123; int partitionIndex = partition(A, start, end); quickSort(A, start, partitionIndex - 1); quickSort(A, partitionIndx + 1, end); &#125; &#125;private static int partition(int[] A, int start, int end) &#123; int pivot = A[end]; int partitionIndex = start; for (int i = start; i &lt; end; i++) &#123; if (A[i] &lt; pivot) &#123; swap(A[i], A[partitionIndex]); partitionIndex++; &#125; &#125; swap(A[partitionIndex], A[end]); return partitionIndex;&#125; PracticeMax Non Negative SubArrayFind out the maximum sub-array of non negative numbers from an array.The sub-array should be continuous. That is, a sub-array created by choosing the second and fourth element and skipping the third element is invalid. Maximum sub-array is defined in terms of the sum of the elements in the sub-array. Sub-array A is greater than sub-array B if sum(A) &gt; sum(B). Example: A : [1, 2, 5, -7, 2, 3]The two sub-arrays are [1, 2, 5][2, 3].The answer is [1, 2, 5] as its sum is larger than [2, 3] NOTE: If there is a tie, then compare with segment&#39;s length and return segment which has maximum lengthNOTE 2: If there is still a tie, then return the segment with minimum starting index 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public static ArrayList&lt;Integer&gt; maxset(ArrayList&lt;Integer&gt; A) &#123; if (A == null || A.size() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; B = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (Integer a : A) &#123; if (a &gt;= 0) &#123; temp.add(a); &#125; else &#123; B.add(temp); temp = new ArrayList&lt;&gt;(); &#125; &#125; B.add(temp); ArrayList&lt;Long&gt; sumList = new ArrayList&lt;&gt;(); long sum = 0; for (int i = 0; i &lt; B.size(); i++) &#123; ArrayList&lt;Integer&gt; bList = B.get(i); for (Integer b : bList) &#123; sum += b; &#125; sumList.add(sum); sum = 0; &#125; long max = 0; for (int i = 0; i &lt; sumList.size(); i++) &#123; if (sumList.get(i) &gt;= max) &#123; max = sumList.get(i); &#125; &#125; return B.get(sumList.indexOf(max)); &#125;&#125; Max Sum Contiguous SubarrayFind the contiguous subarray within an array (containing at least one number) which has the largest sum. For example: Given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. For this problem, return the maximum sum. 123456789101112131415161718192021222324public class Solution &#123; // DO NOT MODIFY THE LIST. IT IS READ ONLY public int maxSubArray(final List&lt;Integer&gt; A) &#123; if (A == null || A.size() == 0 ) &#123; return 0; &#125; int total = A.get(0), maxSum = A.get(0); for (int i = 1; i &lt; A.size(); i++) &#123; if (total &gt;= 0) &#123; total += A.get(i); &#125; else &#123; total = A.get(i); &#125; if (total &gt; maxSum) &#123; maxSum = total; &#125; &#125; return maxSum; &#125;&#125;]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day3]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day3%2F</url>
    <content type="text"><![CDATA[SortingSelection Sort1234567891011121314151617181920212223242526public class SelectionSort&#123; public static void main(String[] args) &#123; int[] A = &#123;3, 4, 2, 5, 8, 1&#125;; int[] B = selectionSort(A); for (int b : B) &#123; System.out.print(b + " "); &#125; &#125; private static int[] selectionSort(int[] A) &#123; int len = A.length; for (int i = 0; i &lt; len - 1; i++) &#123; int iMin = i; for (int j = i + 1; j &lt; len; j++) &#123; if (A[j] &lt; A[iMin]) &#123; iMin = j; &#125; &#125; int temp = A[i]; A[i] = A[iMin]; A[iMin] = temp; &#125; return A; &#125;&#125; 时间复杂度分析： 123456789101112131415for (int i = 0; i &lt; len - 1; i++) --&gt; c1for (int j = i + 1; j &lt; len; j++) --&gt; c2 --&gt; i = 0 ==&gt; n - 1 --&gt; i = 1 ==&gt; n - 2 . . . . --&gt; i = n - 1 ==&gt; 1int temp = A[i];A[i] = A[iMin]; --&gt; c3A[iMin] = temp;T(n) = n * c1 + n(n-1)/2 * c2 + n * c3 = an^2 + bn + c = O(n^2) Bubble Sort123456789101112131415161718private static int[] bubbleSort(int[] A) &#123; int len = A.length; for (int i = 1; i &lt; len; i++) &#123; int flag = 0; for (int j = 0; j &lt; len - i; j++) &#123; if (A[j] &gt; A[j + 1]) &#123; int temp = A[j + 1]; A[j + 1] = A[j]; A[j] = temp; flag = 1; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125; return A;&#125; 时间复杂度分析： 123456789101112131415161718// worstint temp = A[j + 1];A[j + 1] = A[j]; --&gt; cA[j] = temp; --&gt; i = 1 ==&gt; n - 1 --&gt; i = 2 ==&gt; n - 1 . . . . --&gt; i = n - 1 ==&gt; n - 1T(n) = (n - 1)*(n - 1)*c = cn^2 - 2cn - c = O(n^2)// bestT(n) = O(n) // averageT(n) = O(n^2) Insertion Sort1234567891011121314private static int[] insertionSort(int[] A) &#123; int len = A.length; for (int i = 1; i &lt; len; i++) &#123; int value = A[i]; int hole = i; while (hole &gt; 0 &amp;&amp; A[hole - 1] &gt; value) &#123; A[hole] = A[hole -1]; hole--; &#125; A[hole] = value; &#125; return A;&#125; 时间复杂度分析： 1234567891011121314151617181920int value = A[i];int hole = i; --&gt; c1A[hole] = A[hole - 1];hole--; --&gt; c2A[hole] = value; --&gt; c3// bestT(n) = (c1 + c3)*(n - 1) = an + b = O(n) // worstT(n) = (c1 + c3)*(n - 1) + [1 + 2 + 3 + ... + (n - 1)]*c2 = an^2 + bn + c = O(n^2) // averageT(n) = O(n^2) Merge Sort12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static int[] mergeSort(int[] A) &#123; int n = A.length; if (n &lt; 2) &#123; return A; &#125; int mid = n / 2; int[] left = new int[mid]; int[] right = new int[n - mid]; for (int i = 0; i &lt; mid; i++) &#123; left[i] = A[i]; &#125; for (int j = mid; j &lt; n; j++) &#123; right[j - mid] = A[j]; &#125; mergeSort(left); mergeSort(right); merge(left, right, A); return A;&#125;private static int[] merge(int[] left, int[] right, int[] A) &#123; int leftLen = left.length, rightLen = right.length; int i = 0, j = 0, k = 0; while (i &lt; leftLen &amp;&amp; j &lt; rightLen)&#123; if (left[i] &lt; right[j])&#123; A[k] = left[i]; i++; &#125; else &#123; A[k] = right[j]; j++; &#125; k++; &#125; while (i &lt; leftLen) &#123; A[k] = left[i]; i++; k++; &#125; while (j &lt; rightLen) &#123; A[k] = right[j]; j++; k++; &#125; return A;&#125; 时间复杂度分析： 123456789101112131415161718192021222324252627282930313233343536373839int n = A.length;if (n &lt; 2) &#123; return A;&#125; --&gt; c1int mid = n / 2;int[] left = new int[mid];int[] right = new int[n - mid];for (int i = 0; i &lt; mid; i++) &#123; left[i] = A[i];&#125; --&gt; n*c2for (int j = mid; j &lt; n; j++) &#123; right[j - mid] = A[j];&#125;mergeSort(left); --&gt; T(n/2)mergeSort(right); --&gt; T(n/2) merge(left, right, A); --&gt; n*c3 + c4T(n) = c1 + n*c2 + 2T(n/2) + n*c3 + c4 = 2T(n/2) + n*(c2 + c3) + (c1 + c4) = 2T(n/2) + n*c (n &gt;= 2)T(n) = c (n = 1)T(n) = 2T(n/2) + n*c = 2[2T(n/4) + n/2*c] + n*c = 4T(n/4) + 2n*c = 4[2T(n/8) + n/4*c] + 2n*c = 8T(n/8) + 3n*c ... = 2^k*T(n/(2^k)) + k*n*c 令 n/(2^k) = 1 则： 2^k = n，k = log2nT(n) = 2^(log2n)*T(1) + log2n*n*c = n*c + n*c*log2n = n*c*log2n = O(nlog2n)]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一读-2019-06-04]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BB-2019-06-04%2F</url>
    <content type="text"><![CDATA[演讲的技巧在演讲中，难免会出现紧张的情况，甚至会出现错误，这时观众是不会太过于注意的，没有自己想想中的那么严重，需要的是继续进行下去，常用句型： 这里有些小问题，不过不重要，我们来看下一个话题。 没关系（这个小错误并没有太大的影响），我们继续 内向者的演讲者应该学会把握自身的优势，塑造好的形象。 塑造形象的方式自嘲、建立信任、以小见大 内向的人学演讲，一开始最大的问题都是觉得无话可说。因为他们不明白，只要认真发掘自己真正关注的事情，总能找到一些既让听众觉得有意思，又跟演讲主题相关的内容。 用故事性叙述避免大脑空白应对公开演讲时的大脑空白，有一招最简单的方法：故事性陈述，步骤如下： 用故事带大纲：故事本身就是一个完整的大纲，根本不需要刻意去背 讲故事加感想：先点出主题，然后讲一个和主题相关的故事，接着说一点自己对这个故事的感想 贴标签存故事：一个故事可以对应多个主题 胜选演讲赞美对手、弥合分歧、感谢盟友，句型： 我真的非常欣赏…… 我们…… 这不是一次竞争，而是一次运动…… 败选演讲败选演讲的目的是要彰显自己的风度，甚至是为下一次的竞赛胜利打下基础，而表达自己的不服和透露出颓废的感觉都是不可取的。 原则：感谢盟友、威胁对手、澄清误解、重建形象 与观众建立信任 适当地降低观众的预期 在演讲中不动声色地建立起他人对自己专业的信任 讲给重要的人听点破尴尬 其实我也知道大家不爱听，但是为了广告商的利益，我还是要念一段广告 明确主题 虽然大家都急着吃饭，不过我们还是要先祝福新郎新娘 找对听众 也许这些祝福的话大家听起来有些老套，可却是对这对新人最美好的期盼]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day2]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day2%2F</url>
    <content type="text"><![CDATA[ArraysIntroduction To Pointers In C/C++ 12&amp; --&gt; 地址的值* --&gt; 取值]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterviewBit-Day1]]></title>
    <url>%2FInterviewBit%2FInterviewBit-Day1%2F</url>
    <content type="text"><![CDATA[Time Complexity Of A Computer Program “Whats the time complexity of the solution ?” “Can you improve the time complexity of your solution ?” 时间复杂度，选择最差的 主要的时间复杂度有： O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^) 、O(n^3^)、O(n^k^)、O(2^n^)]]></content>
      <categories>
        <category>InterviewBit</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收藏]]></title>
    <url>%2Funcategorized%2F%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[2019-05-31https://github.com/Janche/springboot-security-project https://blog.csdn.net/qq_34997906/article/details/89600076 https://github.com/Janche/springboot-security-project https://github.com/dzinot/spring-boot-2-oauth2-authorization-jwt 2019-06-04 设计一个秒杀系统 设计一个支撑百万用户的IM消息系统 设计一个微信红包系统 设计一个电商平台积分兑换系统：https://juejin.im/post/5ce3cb09f265da1b6028d816 2019-06-25MyBatis 源码分析：https://blog.csdn.net/qq_26323323/article/details/81335058]]></content>
  </entry>
  <entry>
    <title><![CDATA[每月一记-2019-05]]></title>
    <url>%2F%E6%9C%88%E6%80%BB%E7%BB%93%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E8%AE%B0-2019-05%2F</url>
    <content type="text"><![CDATA[2019.5 总结5 月初给自己定了 3 个需要完成的计划： 练习腹肌 痘痘消失 学习素描 练习腹肌计划 1、准备：购买瑜伽垫、寻找腹肌练习教程 2、练习计划：一组 20个，每天 3 组 执行情况 1、瑜伽垫已经购买 2、并没有寻找教程，按照自己的练习计划 3、练习计划总共执行了 3 天，然后就没有做了 结果 计划失败 原因 缺乏执行力，没有人监督，不能很好的坚持 改进 1、由于工作原因或是心理原因，可以适当降低计划执行的频次 2、需要寻找教程，按照教程练习并收获一定的效果 痘痘消失计划 1、原因分析： a、手去摸脸 b、身体内部火气太重 c、脸太过油腻 2、解决方法： a、养成手不去摸脸的习惯 b、饭菜吃清淡，喝板蓝根、凉茶、多喝水 c、早晚使用洗面奶洗脸，午睡后洗脸 执行情况 1、对于手去摸脸这个问题，在前 20 天执行得很好，自己控制得不错，但是后 10 天经常去摸，造成痘痘反复 2、饭菜吃得较为清淡，但是没有做到去购买板蓝根喝 3、坚持了晚上用洗面奶洗脸，午睡后洗脸基本坚持着 结果 由于后面 10 天手去摸脸，造成痘痘有所反复，但是相较于上月，脸上没有大的痘痘冒出，分析后觉得主要得益于饭菜吃得较为清淡和午睡后洗脸。 完成 60% 原因 后面 10 天手不听话，觉得事情不重要就没有去买板蓝根 改进 克制住自己的手，马上去买清热的中药来喝 学习素描计划 根据网上教程学习基本的素描理论，到达能够画简单物体的水平 执行情况 根据网上教程学习了一个一个星期，然后就没有继续学习，也没有勤加练习 结果 学习了握笔方法，学习了画圆的一种方法，没有达到能够画简单物体的水平 完成 20% 算是自己在新领域的尝试吧 原因 没有太大的驱动力，执行力不够强，不行，需要改变 改进 需要花费时间去多画]]></content>
      <categories>
        <category>月总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oauth2 介绍]]></title>
    <url>%2FOauth2%2FOauth2-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[An OAuth 2.0 introduction for beginnersThis article doesn’t want to be the final guide to OAuth 2, but an introduction to the flows that this framework is composed of. You’ll have a look at the four basic flows and some practical scenarios, to understand the involved actors and the detailed behaviors. The goal is to be able to choose a flow that best fits your needs. Which Oauth 2 flow should you choose? To make it as easy as possible, the experts will forgive me, we can say that there are four different versions. Or, more correctly, four different flows. OAuth 2 is the totality of these flows. It’s not mandatory to implement them all, but only the ones that you need. The goal remains always the same: to obtain an access_token and use it to access protected resources. The four modalities are: Authorization Code Grant: A code is issued and used to obtain the access_token. This code is released to a front-end application (on the browser) after the user logs in. The access_token instead, is issued Server side, authenticating the client with its password and the obtained code. Implicit Grant: after the user logs in, the access_token is issued immediately. Client Credential Grant: the access_token is issued on the server, authenticating only the client, not the user. Password Grant: the access_token is issued immediately with a single request containing all login information: username, user password, client id, and client secret. It could look easier to implement, but it has some complications. Authorization Code Grant This is the most complete and complex flow. The login process is divided into two phases, which ensure greater security. The involved actors User: the person who wants to be authenticated, to access protected information. Client App: In this flow, the client is usually the web application. The application must have both a front-end and a back-end, later we’ll see why. This means a pure Front-end application (Javascript, React, Angular) cannot implement this flow but can use the Implicit grant one. Authorization Server: is the component that performs the authentication and the authorization, it handles login requests, user authentication, token generation, and security validations. Resource Server: it exposes resources, as they could be REST API. After the Client App obtains the access_token, will use it to call the Resource Server. One of the differences between the Authorization Server and the Resource Server is that the first one “only” handles authentication and authorization, and the second one “only” serves the content (the resources). This division can generate some confusion: it’s important to remember this is a logic difference and not an implementation rule. The flowLet’s see in detail the Authorization code grant flow. 1. The user wants to log inThe classic scenario for this flow is played in the user browser. The user will click the “Login with OAuth” button and the client will generate and send a login request to the Authorization Server. 2. The user is redirected to the Authorization ServerThe client generates a login request for the Authorization Server. The request will be sent in the form of an HTTP Redirect and the information will be sent as GET parameters. 12GET /tokenLocation: https://the-authorization-server/token?client_id=[the_client_id]&amp;redirect_uri=[a redirect uri]&amp;response_type=code&amp;scope=[list of scopes]&amp;state=[some client parameter] The parameters are the following: client_id: to identify the calling application redirect_uri: the URL to which the Authorization Server will send (through a redirect) the Authorization code, after the user login. response_type: identifies the type of response the Authorization Server will return. The value code is the one usually in the Authorization code flow. scope: a list of permits the application asks the user. For example: read_email, write_post. The user will be asked to grant those permits. This will be useful when the client will access the Resource Server. This one will decide if permit o deny the access. For example a client, logging in with Facebook, ask the email scope. If the client (once obtained the token) calls the /{user-id}/friendlists API, that needs the friend_list scope, will obtain an access denied error. state: this optional parameter will be returned as is to the client, after the login process. It can be used to retrieve information on the client application about, for example, to the user session. 3. Request validationL’Authorization Server must validate all the request parameters: client_id: Does a client exist with this id? Is the client allowed to perform this request? redirect_uri: Can the client use this redirect URI? Is this redirect URI associated with this client? response_type: Is the client allowed to use this response type? scope: Is the client allowed to use this grants? To execute these validations the Authorization server must have previously registered all the client that will access. The onboarding and the maintenance of clients are out of the OAuth scope. 4. Login formThe Authorization server shows the login form, and the user has to insert the username and password, to make the login (step 5 in the picture). After validating the data (step 6 in the picture) the Authorization server asks the user the consents specified in the scopes. The user will decide to grant, or not, one or more of the scopes. In a contrary case, the client will act in a different manner. For example, it could limit or inhibit the use of the application. 7. Redirect to the client with the authorization_codeThe Authorization Server generates an authorization code (authorization_code) and sends it to the client, to the URI specified in the request. All these operations have happened client side, on a browser (or a mobile app) for the next steps the client must use a back-end. This, in my opinion, is one of the aspects to consider when you choose which OAuth 2 flow best fits your needs. 8 and 9. Authorization code validationNow the client has to call the Authorization Server to validate the received code. To do this operation it will pass: the authorization_code to be validated. the client_id: this is needed, along with the client_secret, to be sure the request actually comes from that client, and the token is not “stolen” when you were on the front-end. the client_secret is the client password, and it must be stored in a safe place, this is why you need a back-end. The Authorization Server executes all the above validations, checking the authorization_code is intact, not altered, not expired and issued for that specific client. 10. The client receives the access_tokenThe Authorization server creates an access_token and returns it to the client. There are many types of token, they have an expiration date and they can be refreshed. Usually, along with the token, are returned some more information: the token_type: one of most famous is Bearer, that means: grant access to the bearer of this token. mac is another type. expires_in: the duration of the token refresh_token: another token, to renew the access_token when it expires. 11. The client uses the access_token.Now that the client has obtained the access_token, it can use it to authenticate itself against the Resource Server. The Resource Server is a generic component and could serve many different types of resources: REST API, SOAP Services, Web pages, etc… Based on the resource type, the method to send the access_token can change. The most common way to send it against REST API is to use the HTTP header: Authorization, concatenating the token_type with access_token. Example: 1Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ 12 and 13. Token validationWhen the Resource Server receives a request must check the token presence and integrity. The token validation, especially based on its type, can be done in many ways. In some cases the Resource Server can validate it, in some other must call the Authorization server. In some scenarios is possible that these two components are the same application, this is transparent and not important for the client. If you need to implement an OAuth server the choice on how to validate the token will vary based on your architecture and on the token type you’ll decide to use. 14 and 15. Access and display the protected resources.Once the Resource server validates the token successfully, it will return the resource to the client, and this can display it to the user. Implicit Grant Flow This flow is very similar to the Authentication Code one, but the access_token is immediately returned to the client after the user login, in an implicit way. You use this flow in Single Page Applications and pure Javascript applications, where is not possible to keep the client_secret secret. The actors involved are the same as the previous flow. The first difference is that during the initial redirect to the Authorization server, the value of the parameter response_type is token instead of code. This means the type of response from the server will be (immediately) an access_token, instead of an authorization_code. In this way, you’ll have one step fewer to execute for the client, but also less secure, because the whole flow is executed on the browser (or user-agentgenerally speaking), including the token. In the authorization code flow, the token comes from a server to server call, so it is more difficult to intercept or manipulate it. Client Credential The main difference between the flows mentioned above is that in this one there is no user interaction. The application executes the authentication request directly. This means the application cannot do any action on behalf of the user, but just on behalf of itself. This flow doesn’t take place on the browser but on a server. There are not redirect, but an HTTP POST call is executed, the parameters of the requests are: client_id client_secret grant_type: client_credentials 1234POST /token&amp;client_id=my-fancy-client-application&amp;client_secret=xxxxxxx&amp;grant_type=client_credentials The response of this request is the access_token, that can be spent on the Resource server. Password Grant flow The main concept, in my opinion, of this flow, is the users enter their username and password in the client application and not in the Authorization Server. A noticeable thing is the credentials “belong” to the Authorization Server, not to the client, This fact implies that the users must fully trust the client application, to insert their Authorization Server credentials. To better understand this, imagine you make an application that logs in users with Facebook, but the users insert their (Facebook) username and password on that application. Would you, as a user, do this? You must be sure the application is absolutely trusted and, for example, does not save or modify your Facebook password. if I remember correctly, Spotify has this feature, probably using this OAuth 2 flow. I remember I did a login using Facebook credentials directly on Spotify. Once the username and the user password are collected on the front-end, they are sent to the application back-end, that executes an HTTP POST to the Authorization Server. The parameters of this request are: grant_type: password username of the user password of the user client_id client_secret 123456POST /tokengrant_type=password&amp;username=username@authorization-server.com&amp;password=TheUserPassword&amp;client_id=my-fancy-client-app&amp;client_secret=xxxxxxx The Authorization server, after validating all the credentials returns the l’access_token. For this flow, you need both a front-end and a back-end. Implementation of OAuth 2To implement OAuth 2 you have to develop: The client: if you want to use an Authorization Server services The server: if you want to expose authentication mechanisms Client sideYou must remember, again, that to implement some of the OAuth flows you need to use the client password, and this must be kept in a secure place. So you may need a server. This means you cannot implement some flows if you don’t have a server. The applications that don’t need a server ( to be served) are Single Page Application and the application that runs on a user device: Mobile and Desktop app. You can bypass this problem by creating a dedicated server or back-end to do the OAuth server calls, or by using some crypt mechanisms. Server sideThere are many frameworks in many languages that implement OAuth. This makes life a little easier, for the part of exposing the needed endpoints; and especially for all the validations that are needed. But rarely I found “turnkey” solutions. One hard thing to do is the onboarding and the management platform for the clients. Just think about the many existing developers.[preferred-social-network].com to understand they are complex applications. You also have to pay attention to the scopes and permissions, whose management is everything but banal, especially in the resource protection phase. Another point of interest is the token management. Use of a database is required, to guarantee the complete lifecycle: release renewal expiration revocation Which flow should I choose? Answer these questions, and you will find out which best fits to you. The choice of the right flow depends on many factors, answer these questions to have an idea of which best fits you. Are you able to maintain the client_secret in a safe and secret place? Yes: next question No: IMPLICIT GRANT Is your application a Web one? Yes: Answer next question No: CLIENT CREDENTIAL GRANT Do your users trust you enough to insert their credentials (username and password) on your site? For example: Would users insert their Facebook password on your site? Yes: PASSWORD GRANT No: AUTHORIZATION CODE GRANT ConclusionI hope the world of OAuth is more clear now that you read this article, my goal was to explore the basics of this protocol. If you have any comment or proposition you are welcome to leave them down here. via: https://itnext.io/an-oauth-2-0-introduction-for-beginners-6e386b19f7a9 作者：Lorenzo Spyna]]></content>
      <categories>
        <category>Oauth2</category>
      </categories>
      <tags>
        <tag>Oauth2 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一读-2019-05-31]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BB-2019-05-31%2F</url>
    <content type="text"><![CDATA[谈判的本质就是交换 谈判第一步收集信息，生活中更多的是小谈判，比如：写一篇文章多少钱、演讲一次多少钱、讨论这个事情要花费多少时间等等，这些谈判中收集信息就用旁敲侧击的方式，三种常见问句： 1、您是怎么知道我们的？ 2、在这方面，你们之前做过的最大的单子是多少？ 3、按照这样的条件，我给您推荐别人好不好？ 这几种只适用于小型谈判，面对大型谈判，需要在之前做充足的准备。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写带图片的文章]]></title>
    <url>%2FHexo%E6%95%99%E7%A8%8B%2FHexo%E5%86%99%E5%B8%A6%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1、修改主配置文件 _config.yml 中的 post_asset_folder 为 true 2、在 Hexo 目录下安装本地文件上传插件：npm install hexo-asset-image --save 3、创建一篇文章 hexo n &quot;test001&quot;，这时在 source/_posts 中会生成一个 test001.md 文件和一个同名的 test001 文件夹 4、在 test001.md 中引入图片时，将图片放到 test001 文件夹下，然后通过 Markdown 标准格式 ![描述](test001/xxx.png) 进行图片引用]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第五节-总结]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-5-Summary%2F</url>
    <content type="text"><![CDATA[总结在本章中，我们了解了您的服务可能会对入侵者造成的一些攻击。我们希望能够介绍加密的工作原理，以及我们如何利用 Go 的标准软件包来实现加密，以确保我们的服务安全。几乎没有什么可以完全保护自己免受坚定的攻击者的攻击；但是，使用本章中描述的简单技术应该构成您的标准工作实践。实施许多这些技术不会在很大程度上减缓您的开发周期；但是，它会给你一个保证你系统安全的优势。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第四节-维护]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-4-Maintenance%2F</url>
    <content type="text"><![CDATA[维护保持系统安全的一个重要因素是，确保使用所有最新的安全补丁使其保持最新。这种方法需要应用于您的应用程序代码、服务器的操作系统和应用程序，如果您使用的是 Docker，还需要确保容器是最新的，以确保您没有漏洞。 为容器打补丁保持容器安全的最简单方法之一是确保定期构建和部署容器。通常情况下，如果服务没有处于活跃开发阶段，那么它可能不会在几个月内部署到生产中。由于此问题，您可能正在修补主机级应用程序库（如 OpenSSL），但由于容器提供的应用程序隔离，您可能在容器级别拥有易受攻击的二进制文件。保持最新状态的最简单方法是运行常规构建和部署，即使应用程序代码没有更改。您还需要确保如果在 Dockerfile 中使用基本容器，也会构建和更新它。 Docker hub，quay.io 和其他几个软件作为服务注册表，能够在链接容器更改时自动重建容器。如果要构建基于 golang：latest 的映像，则可以在将上游映像推送到注册表时自动触发构建。您还可以运行自动安全扫描，该扫描会检查映像中的图层并扫描任何 CVE 漏洞。它会让你知道漏洞存在于哪一层，你经常会发现这是在基础层，如 Ubuntu 或 Debian。 软件更新在主机和 Docker 映像中修补软件，可以帮助您远离 Openble 中的 Heartbleed 等漏洞。修补软件更新相对简单。您可以将主机配置为自动更新；我更喜欢的另一个选择是确保您的基础架构自动化，以便您可以将其清除并重建。 修补应用程序代码与主机上的软件需要更新的方式相同，您还必须更新应用程序代码以确保始终拥有最新的更新。通常，遵循将应用程序依赖关系锁定到版本的方法，并使用 Go 1.5 中引入的 vendoring 支持，此过程在社区中不断增长。这个问题的一个问题是，在 1.5 之前的版本中没有出现 vendoring 的主要原因之一是，鼓励您针对最新的软件包构建应用程序代码，并尽快修复因 API 更改而发生的任何问题。如果您确实使用了 vendoring，我肯定不会建议您不使用它，那么您应该每晚运行项目构建，将所有库更新到最新版本。您不一定要将其部署到生产中；但是，如果测试通过那么为什么不呢？即使它是一个没有正在开发的服务，如果测试失败，那么这也应该是你进行维护的理由。 日志记录如果我们保护了密码并实现了良好的安全性，我们仍然需要知道我们会何时受到威胁。在上一章中，我们介绍了日志记录，日志记录可以作为安全策略的一部分。考虑有人试图强行申请登录；当您需要对此威胁做出反应时，跟踪高级别的身份验证错误以及源 IP 可能非常有用。防火墙可以阻止攻击者的 IP 地址。 日志文件的内容需要考虑以下属性： 谁做出的这个行为 什么失败了或是成功了 行为什么时候出现的 为什么这个行为失败或是成功 你如何处理这个问题 以下示例包含的信息远远不够有用，事实上，除了让您知道可能存在故障之外，您甚至可能不会消耗此类日志所占用的空间： Aug 18 11:00:57 [AuthController] Authentication failed 以下示例要好得多；它以更深入的方式显示问题，并详细描述了用户访问系统所采取的事件。现代日志评估工具（如 Kibana）允许过滤和分组此类日志文件，从而可以构建仪表盘或事件列表： Aug 18 11:00:57 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - user unknown - /user/login /user/myaccount Aug 18 11:01:18 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - invalid password - /user/login?err=1 /user/login Aug 18 11:02:01 [AuthController] Authentication failure for nicj@example.com by 127.0.0.1 - incorrect 2FA code /user/login?err=2 /user/login 例如，您可以创建一个仪表盘，该仪表盘查看来自单个 IP 地址超过特定阈值的失败尝试次数，这可能表示恶意尝试强制访问系统。通常可以对此类事件设置警报，使您可以主动识别威胁并阻止访问。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第二节-外部安全性]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-2-External-Security%2F</url>
    <content type="text"><![CDATA[外部安全性外部安全是保护系统安全的第一道防线，通常包括第 2 层或第 3 层防火墙、DDoS 防护、web 应用防火墙以及其他软件和硬件层面的保护。在攻击者能够危及您的应用程序之前，他们必须首先通过这些硬件和软件层，这些层不是您的应用程序代码的一部分，而是应用程序中许多组件可能共享的共享基础架构层。在本节中，我们将介绍一些外部安全性以及可能对您使用的一些攻击。保护服务的边界通常是由操作完成的任务，但是作为开发人员，我们需要了解流程和风险，因为它极大地增强了我们加固应用程序代码的能力。在本节中，我们将介绍外部安全性的通用方法以及黑客可以利用您的系统的一些方法。 第 2 或第 3 层防火墙第 2 层更常用于路由，因为它只处理 MAC 地址而不处理 IP 地址，而第 3 层可识别 IP 地址。根据传统，第 2 层是唯一真正的不会增加延迟的方法，因为它的执行速度与网线速度大致相同。随着处理能力和内存的增加，第 3 层现在也以网线速度运行，一般来说，当我们查看边缘防火墙时（通常是系统的第一个入口点），它们现在将会是第 3 层。那么这给了我们什么提示呢？首先，它阻止边缘网络不需要的流量：我们限制外部世界可访问的端口，同时一些导向不允许访问内容的流量在防火墙处被拦截，这样就没有机会从源上进行攻击。除此之外，它还允许我们限制对某些端口的访问。例如，如果您正在运行服务器，则很可能需要某种形式的远程访问，例如 SSH。2015 年出现的 Heartbleed 漏洞利用了 OpenSSH 中的漏洞，直接暴露在网络上的 SSH 服务器很容易受到这种攻击。有效地使用防火墙意味着 SSH 等专用端口将被锁定到 IP 地址或 IP 范围，这可能是您的 VPN、办公室 IP 或公共 IP。这大大减少了攻击者利用此功能进行攻击的媒介，因此当您运行易受 Heartbleed 攻击的 OpenSSH 版本时，你需要将这些 SSH 连接置于受保护区域内。 Heartbleed 漏洞利用了执行缓冲区溢出的能力进行攻击，例如，您要求服务器提供 4 个字母的单词，但指定长度为 500；你得到的是 4 个字母的单词，剩下的 496 个字符是跟随初始分配的内存地址的内存块。实际上，这就允许黑客随机访问服务器中的内存块；这些内存块可能包含更改密码请求等项目，这些项目为其提供访问服务器的凭据。如果您正在运行全局可用的 SSH 服务器，那么您可能会发现存在问题： Web 应用程序防火墙Web 应用程序防火墙（WAF）被配置为系统中的第二道或第三道防线。要了解 WAF 是什么，让我们看看 开源 Web 应用程序安全项目（OWASP）中的定义： “Web 应用程序防火墙（WAF）是 HTTP 应用程序的防火墙。它将一组规则应用于 HTTP 会话。这些规则涵盖了常见的攻击，如跨站点脚本（XSS）和 SQL 注入。 当代理技术保护客户端时， WAF 保护着服务器。部署 WAF 以保护特定 web 应用程序或 web 应用程序集。WAF 可以被视为反向代理。 WAF 可能以应用、服务器插件或过滤器的形式出现，并且可以针对应用程序进行定制。执行此自定义的工作量很大，需要在修改应用程序时进行维护。“ OWASP 是一个非常有用的资源，实际上为 ModSecurity 提供了一个核心规则集，可以防止 SQL 注入、XSS、Shellshock 等攻击。设置 WAF（如ModSecurity 和 OWASP CRS）应该是您的最低要求。在 Docker 容器中托管这个应该是相对微不足道的，这可能形成第 2 层防火墙后面的第二道防线。 还有另一种选择：一些像 Cloudflare 这样的 CDN 公司提供托管的 WAF。这是对网络边缘的保护，并且由于Cloudflare 等企业的专业知识，您无需担心配置问题。事实上，Cloudflare 支持 OWASP CRS。 API 网关除了 WAF，API 网关也是一个有用的工具；这可以实现双重目的，即将公共 API 路由到其后端服务以及一些其他功能，例如边缘的令牌验证以及输入验证和转换。当我们谈到困惑的代理人问题时，防火墙后面的攻击者可以执行他们没有权限的命令，我们研究了加密网络令牌的可能性；这个问题是用于解密这些令牌的私钥需要分布在多个后端服务中。这使得管理密钥比其应有的难度更具挑战性。API 网关可以通过成为唯一可以解密消息的层来简化这种情况。其他服务使用公钥来验证签名。API 网关通常实现许多其他第一线功能，例如但不限于以下内容： 请求验证 授权 速度限制 日志记录 缓存 请求和响应传递 WAF 和 API 网关之间存在交叉元素；但是，这两个应该被视为基础设施的两个截然不同的部分。关于 API 网关的提供者，这似乎是一个发展中的领域；AWS 具有高级 API 网关，如果您已购买 AWS PaS环境，则可以使用该网关。 对于独立部署，Kong，Tyk，Apigee，Mashery 和 Mulesoft 的 Anypoint Platform 都是该领域的领导者。当然，可以使用 Nginx 或 HAProxy 构建自己的 API 网关；但是，在开始构建自己的平台之前，我建议首先要看一看以上特定平台中的一个。 DDoS 防护2016 年 10 月 21 日，攻击者使用 Mirai 僵尸网络攻击 DYN 的 DNS 服务器造成了一次大规模的网络瘫痪。Mirai 漏洞利用了中国的雄迈信息技术有限公司制造的 IP 摄像机和 DVR 的漏洞攻击者不是攻击目标，而是决定取消互联网基础设施的主要部分，淘汰美国东海岸和西海岸的大部分地区。Mirai 漏洞只利用 60 个用户名和密码来尝试更新易受攻击设备的固件。一旦安装了恶意软件，该设备就可以被僵尸网络控制。剩下要做的就是告诉机器人开始针对 DYN 域名服务器进行 DNS 攻击。 Mirai 的代码已经发布在网上；你可以使用谷歌轻易地找到它。你会为这个代码的简单程度感到惊讶。现在，我不想从设计这种攻击的复杂性中得到任何东西；我只谈谈实现。该漏洞的相当大一部分代码是用 Go 编写的，因此非常易读。channel（通道）有一些很好的用途。如果您查看代码，请尝试甄别可以使用信号量改进的代码段。 Akamai 发布的一份报告指出，今年所有攻击中有 98.34％ 是面向基础设施的，只有 1.66％ 的目标是应用层。在 98.34％ 中，只要保持网络环境干净，许多是可以避免的。让我们看看顶级威胁及其运作方式。 DDoS 攻击类型以下是 DDoS 攻击的类型“ UDP 碎片 DNS NTP Chargen UDP SYN SSDP ACK UDP 碎片攻击UDP 碎片攻击是攻击者利用数据报碎片在网络上工作的方式。每个网络都有一个称为最大传输单元（MTU）的限制。如果发送到网络的数据报大于 MTU，则其会被分割成碎片进行传输。 UDP 碎片攻击的工作原理是创建包含假包的数据报；当服务器试图重新组装这些包时，它无法完成，资源很快就会被消耗殆尽。 UDP 泛洪攻击UDP 泛洪攻击的工作原理是将大量带有欺骗源地址的 UDP 数据包发送到 IP 地址。服务器将响应这些请求，向欺骗的地址发送回复。由于大量的攻击，路由器将超过其每秒 UDP 数据报的限制，并在一段时间内对同一安全区域中的所有地址停止发送消息。 这通常也使用称为反射攻击的技术。当源地址 IP 被欺骗时，返回数据包不会被发送回真实源，而是发到被欺骗的 IP 地址。使用此技术的原因是它允许发送方通过仅消耗出站数据包上的资源来放大攻击。 DNSDNS 攻击利用 UDP 泛洪攻击来获取 DNS 服务器；许多请求被用于查询 DNS 服务器。这些请求旨在从一个微小的请求返回一个非常庞大的回复，以最大限度地提高攻击效率，因为发送者通常不会收到响应。 我们在早些时候看到的针对 Dyn 的基础设施的攻击，在 2016 年 10 月在美国东海岸和西海岸取出了许多网站，这种攻击就是 DNS 攻击。与大多数 DNS 攻击不同，Miraia 网络不使用反射攻击技术，它允许将响应返回给发送方，这可能是由于大量受损设备造成的。 NTPNTP 是另一种放大攻击，它利用 NTP 服务器内置的功能，返回最后 600 台与之交互的机器。此攻击利用了支持 MONLIST 命令且尚未修补的开放 NTP 服务器。项目 http://openntpproject.org/ 旨在识别未修补的服务器，以鼓励删除此漏洞。不幸的是，NSFOCUS 在 2014 年进行的研究发现，全球有超过 17,000 台服务器容易受到攻击。假设所有这些服务器都可以使用，并且使用 2014 年遭遇 CloudFlare 的 NTP 攻击的有效载荷大小，我们就有了 1.4Tbps 的 DDoS 攻击能力。这种流量将是目前已知的最大攻击的两倍。NTP 为最强大的应用程序攻击之一提供了一个平台，并且仅由于服务器修补不良而存在。 CHARGENCHARGEN（字符生成协议）攻击是另一种反射放大攻击。攻击利用开放的 CHARGEN 服务器，每次从连接的主机接收数据报时，在端口 19 上运行的服务器将返回 0 到 512 之间的随机字符长度。CHARGEN 旨在作为一种字节流的源来调试 TCP 网络代码和带宽测量。CHARGEN 攻击通过滥用已在网络连接的打印机上启用的 CHARGEN 服务器来工作。 SSDP简单服务发现协议（SSDP），通常用于发现 即插即用（UPnP）设备。这正是您的家用路由器实现的协议，所以下次当您抱怨您最喜欢的游戏网络离线时，为什么不先检查您是否无意中将 SSDP 暴露在互联网上？ ACKACK 泛洪利用客户端连接到服务器时存在的三次握手。第一步是客户端发送一个 SYN 数据包，从服务器回复 SYN-ACK 数据包。然后客户端最后回复一个 ACK 数据包，然后为数据开放连接。ACK 泛洪采用以下两种形式之一： 攻击者向服务器发送一个欺骗性的 SYN 数据包，然后使用一个伪造的 SYN-ACK 数据包。服务器打开并保持开放的连接。如果打开了足够多的连接，则服务器最终将耗尽资源。 第二种方法是仅发送 ACK 包。由于服务器没有开放连接，因此该数据包将被丢弃；但是，它仍然消耗必须处理这些数据包的资源。 攻击类似于 SYN 攻击；但是，由于它欺骗 DDoS 过滤器将数据包传递到服务器的方式，它可以更有效。 避免这些攻击并非如此简单：您需要在网络边缘检测并过滤此活动。您还需要大量带宽来吸收系统入站的流量，在我看来，这不是内部解决方案可以或应该解决的问题。 避免 DDoS 攻击的第一道防线是确保您没有启用它们。配置防火墙以确保您不暴露易受攻击的服务，并修补您的服务意味着攻击者无法使用您的网络基础架构来攻击其他人。第二条是利用 Cloudflare，Akamai，Imperva 或其他拥有基础架构和网络过滤器的专家的力量，来确保流量永远不会到达您的服务器。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-第一节-加密与签名]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-1-Encryption-and-Signing%2F</url>
    <content type="text"><![CDATA[加密和签名当我们研究保护数据的方式时，无论是静态还是动态，我们讨论的许多方法都将以加密方式保护数据。 ”密码学是使用数学来加密和解密数据的科学。密码学使你能够存储敏感信息或通过不安全的网络（像互联网这样的线路）传输它，这样除了预期的接收者之外，任何人都无法读取它。“ – 密码学概论，Network Associates 公司 作为我们将在本章讨论的事情的基础，我们必须首先了解密码学如何工作的，不是需要我们有数学学位，而是只到涉及所涉及的部分的程度。密码学与所涉及的密钥的安全性差不多，我们需要知道哪些密钥可以自由分发，哪些密钥需要用我们的生命去保护。 对称密钥加密对称密钥加密也称为秘密密钥或传统密码术：一个密钥用于数据的加密和解密。要使远端能够解密此信息，它必须首先拥有密钥，并且必须安全地保存此密钥，因为一个服务器的单一泄密将危害共享此密钥的所有服务器。它还会使密钥管理变得更加复杂，因为当你需要更改密钥时，你应该经常更改它，你需要在整个磁盘中推出此更改。 公钥加密公钥加密由 Whitfield Diffie 和 Martin Hellman 于 1975 年引入，以满足双方需要了解秘密的需要。事实上，他们并不是第一个发明这一点的人；它是几年前英国特勤局开发的，但却保留了军事秘密。 公钥加密使用一对密钥进行加密；你也会听到称它为非对称加密。公钥用于加密信息，而私钥只能用于解密。由于无法从公钥中确定私钥，因此公钥通常会发布到全世界。 数字签名公钥加密还使我们能够使用数字签名。数字签名工作方式是，通过使用私钥加密消息然后传输签名消息。如果可以使用公钥解密消息，则消息必须源自私钥的持有者。由于加密消息的计算时间和有效载荷大小的增加，标准方法是创建消息的单向哈希，然后使用私钥对其进行加密。接收方将使用公钥解密哈希，并从消息中生成相同的哈希；那么，该消息可以被认为来自可信赖的来源。 X.509 数字证书公钥的一个问题是你必须确保你认为属于收件人的密钥确实由收件人拥有。如果密钥通过公共网络传输，则始终存在中间人攻击的可能性。攻击者可能会伪造一个虚假的公钥，因为你认为它是你信任的收件人；但是，他们可以用他们的密钥替换。这意味着你认为安全传输的消息实际上可能被恶意第三方解密和读取。 为了避免这些问题，数字证书出现了，它简化了确定公钥是否属于报告所有者的任务。 数字证书包含三件事： 一个公钥 证书信息，例如所有者的姓名或 ID 一个或多个数字签名 使证书值得信赖的是数字签名。证书由受信任的第三方或证书颁发机构（CA）签名，该机构担保你的身份和你的公钥是属于你的。任何人都可以创建 CA 根证书并签署他们的证书，对于诸如微服务间通信等系统的非公共访问，这是一种常见的做法。但是，对于公共证书，你需要向 CA 支付签署证书的费用。定价的目的是 CA 将会确保你确实是你所说的人；目前，最受欢迎的 CA 是 Comodo、 Symantec （前身为 Verisign）和GoDaddy。你在浏览器中看到挂锁的原因不仅仅是因为你使用的是安全通信，而且您的浏览器已经验证了证书的签名是否与 100 个左右的可信第三方之一捆绑在一起。 TSL/SSLSSL 是两个系统之间安全传输数据的常用术语，它是对 Mozilla 于 1995 年首次开发的弃用标准的引用。它已被 2008 年 8 月发布的 TLS 1.2 取代；虽然 SSL 3.0 在技术上仍然有效，但在针对 POODLE（Paddling Oracle On Downgraded Legacy Encryption）攻击的漏洞后，它在 2015 年 6 月被弃用。2014 年，Google 安全研究团队发现的 POODLE 攻击工作原理是攻击者向服务器发出多个请求，然后分析和使用这些数据，这些数据使他们能够解密传输中的数据。平均而言，只需要进行 256 次 SSL 3.0 调用即可解密 1 字节的信息。 这意味着该漏洞在公开披露之前已存在 18 年；你可能会问为什么人们在强大的 TLS 1.0 发布 15 年后仍在使用 SSL 3.0？这是由于某些浏览器和服务器不支持 TLS 1.0 的问题，因此存在一个回退到较低级别加密的回退。尽管在发现时，几乎没有人仍在使用 SSL 3.0，但回退仍然在协议中，因此可被黑客利用。解决方案非常简单：在服务器配置中禁用低于 TLS 1.0 的任何内容。我们了解了一些 TLS 和 SSL 的历史，但它如何保证您的数据安全？ TLS 使用对称加密，其中客户端和服务器都有一个用于加密和解密的密钥。如果你还记得上一节，我们介绍了对称加密和分发密钥的问题。TLS 通过在握手的第一部分使用非对称加密来解决这个问题。客户端从服务器检索包含公钥的证书并生成随机数；它使用公钥加密此随机数并将其发送回服务器。现在双方都有随机数，他们使用它来生成对称密钥，用于传输过程中对数据加密和解密。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-安全性]]></title>
    <url>%2FGo%E6%95%99%E7%A8%8B%2F8-0-Security%2F</url>
    <content type="text"><![CDATA[安全性微服务中的安全性可能就像一个雷区，在某种程度上确实是这样。本章主要介绍一些可以提高 Go 代码安全性的方法；但是，我觉得讨论一些更为广泛的问题也很重要。对防火墙配置等话题的深入讨论最好留给专业的书籍；但是，我们将介绍一些概念和所面临的问题，以便您可以为进一步阅读做好最充分的准备。]]></content>
      <categories>
        <category>Go教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
